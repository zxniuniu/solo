<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="theme-color" content="#3b3e43"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no"/><title>Javascript Injection With Selenium, Puppeteer, And Marionette In Chrome And Firefox - 随心笔客</title><meta name="description" content="Browser automation frameworks–like Puppeteer, Selenium, Marionette, and Nightmare.js–strive to provide rich APIs for configuring and interacting with Web browsers. These generally work quite well, but you’re inevitably going to end up running into API limitations if you do a lot of testing or Web scraping. You might find yourself wanting to conceal the fact that you’re using a headless browser, extract image resources from a Web page, set the seed for Math.random(), or mock the browser’s geolocation before running your test suite. Your specific automation framework might provide a built-in way to accomplish some of these, but they all have their limitations."/><meta property="og:description" content="Browser automation frameworks–like Puppeteer, Selenium, Marionette, and Nightmare.js–strive to provide rich APIs for configuring and interacting with Web browsers. These generally work quite well, but you’re inevitably going to end up running into API limitations if you do a lot of testing or Web scraping. You might find yourself wanting to conceal the fact that you’re using a headless browser, extract image resources from a Web page, set the seed for Math.random(), or mock the browser’s geolocation before running your test suite. Your specific automation framework might provide a built-in way to accomplish some of these, but they all have their limitations."/>    <meta name="keywords" content="博客,开源,分享,平台,自媒体,原创,随心笔客,图库"/><link rel="dns-prefetch" href="https://cdn.jsdelivr.net/gh/88250/solo@4.3.1/src/main/resources"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://cdn.jsdelivr.net/gh/88250/solo@4.3.1/src/main/resources"><link rel="icon" type="image/png" href="favicon.ico"/><link rel="apple-touch-icon" href="favicon.ico"><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"><meta name="copyright" content="B3log"/><meta http-equiv="Window-target" content="_top"/><meta property="og:locale" content="zh_CN"/><meta property="og:title" content="Javascript Injection With Selenium, Puppeteer, And Marionette In Chrome And Firefox - 随心笔客"/><meta property="og:site_name" content="随心笔客"/><meta property="og:url"      content="https://zxniuniu.github.io/articles/2018/10/12/1539357955729.html?"/><meta property="og:image" content="favicon.ico"/><link rel="search" type="application/opensearchdescription+xml" title="Javascript Injection With Selenium, Puppeteer, And Marionette In Chrome And Firefox - 随心笔客" href="/opensearch.xml"><link href="https://zxniuniu.github.io/rss.xml" title="RSS" type="application/rss+xml" rel="alternate"/><link rel="manifest" href="https://zxniuniu.github.io/manifest.json">        <link rel="canonical" href="https://zxniuniu.github.io/articles/2018/10/12/1539357955729.html">        <link rel="stylesheet"
              href="https://cdn.jsdelivr.net/gh/88250/solo@4.3.1/src/main/resources/skins/9IPHP/css/base.css?1606610382706"/>
            <link rel="prev" title="App爬虫神器Mitmproxy和Mitmdump的使用" href="https://zxniuniu.github.io/articles/2018/10/12/1539357030798.html">
            <link rel="next" title="A Web Developer’s Guide to Browser Caching" href="https://zxniuniu.github.io/articles/2018/10/18/1539837869502.html">
    <!--<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>-->

<!--<iframe frameborder="0" border="0" marginwidth="0" marginheight="0" width="90%" height=88 src="//music.163.com/outchain/player?type=2&id=1313363070&auto=1&height=66"></iframe>-->

<!--<font color='green' size='5em'><strong>FAMILY</strong></font> = <font color='green' size='5em'><strong>F</strong></font>ather <font color='green' size='5em'><strong>A</strong></font>nd <font color='green' size='5em'><strong>M</strong></font>other <font color='green' size='5em'><strong>I</strong></font> <font color='green' size='5em'><strong>L</strong></font>ove <font color='green' size='5em'><strong>Y</strong></font>ou--><script src="https://cdn.jsdelivr.net/npm/vditor@3.5.3/dist/js/icons/ant.js" async="" id="vditorIconScript"></script></head>
<body>
<header>
    <div class="banner">
        <div class="fn-clear wrapper">
            <h1 class="fn-inline">
                <a href="https://zxniuniu.github.io" rel="start">
                    随心笔客
                </a>
            </h1>
            <small> &nbsp; 张小妞的个人博客</small>
        </div>
    </div>

    <div class="navbar">
        <div class="fn-clear wrapper">
            <nav class="fn-left">
                <a href="https://zxniuniu.github.io">
                    <i class="icon-home"></i>
                    首页
                </a>
                    <a href="/my-github-repos" target="_self" rel="section">
                        <img class="page-icon" src="/images/github-icon.png" alt="我的开源">我的开源
                    </a>
                <a href="https://zxniuniu.github.io/tags.html" rel="section">
                    <i class="icon-tags"></i> 标签墙
                </a>
                <a href="https://zxniuniu.github.io/archives.html">
                    <i class="icon-inbox"></i> 存档
                </a>
                <a rel="archive" href="https://zxniuniu.github.io/links.html">
                    <i class="icon-link"></i> 友链
                </a>
                <a rel="alternate" href="https://zxniuniu.github.io/rss.xml" rel="section">
                    <i class="icon-rss"></i> RSS
                </a>
            </nav>
        </div>
    </div>
</header>
<div class="responsive fn-none">
    <i class="icon-list"></i>
    <ul class="list">
        <li>
            <a href="https://zxniuniu.github.io">
                <i class="icon-home"></i>
                首页
            </a>
        </li>
            <li>
                <a href="/my-github-repos" target="_self" rel="section">
                    <img class="page-icon" src="/images/github-icon.png" alt="我的开源">我的开源
                </a>
            </li>
        <li>
            <a href="https://zxniuniu.github.io/tags.html" rel="section">
                <i class="icon-tags"></i> 标签墙
            </a>
        </li>
        <li>
            <a href="https://zxniuniu.github.io/archives.html">
                <i class="icon-inbox"></i> 存档
            </a>
        </li>
        <li>
            <a rel="archive" href="https://zxniuniu.github.io/links.html">
                <i class="icon-link"></i> 友链
            </a>
        </li>
        <li>
            <a rel="alternate" href="https://zxniuniu.github.io/rss.xml" rel="section">
                <i class="icon-rss"></i> RSS
            </a>
        </li>
    </ul>
</div>
<div class="wrapper">
    <div class="main-wrap">
        <main>
            <article class="post">
                <header>
                    <h2>
                        <a rel="bookmark" href="https://zxniuniu.github.io/articles/2018/10/12/1539357955729.html">
                            Javascript Injection With Selenium, Puppeteer, And Marionette In Chrome And Firefox
                        </a>
                    </h2>
                    <div class="meta">
                                <span class="vditor-tooltipped vditor-tooltipped__n"
                                      aria-label="更新日期">
                                    <i class="icon-date"></i>
                                    <time>
                                    2019-10-15
                                    </time>
                                </span>
                        &nbsp; | &nbsp;
                        <span class="vditor-tooltipped vditor-tooltipped__n" aria-label="评论数">
                                    <i class="icon-comments"></i>
                                    <a href="https://zxniuniu.github.io/articles/2018/10/12/1539357955729.html#b3logsolocomments">
                                        <span data-uvstatcmt="1539357955729">0</span> 评论</a>
                                </span>
                        &nbsp; | &nbsp;
                        <span class="vditor-tooltipped vditor-tooltipped__n" aria-label="浏览数">
                                    <i class="icon-views"></i>
                        <span data-uvstaturl="https://zxniuniu.github.io/articles/2018/10/12/1539357955729.html">0</span> 浏览
                                </span>
                    </div>
                </header>

                <div class="vditor-reset post__content">
                    <p>Browser automation frameworks–like <a href="https://github.com/GoogleChrome/puppeteer" target="_blank">Puppeteer</a>, <a href="http://www.seleniumhq.org/" target="_blank">Selenium</a>, <a href="https://marionette-client.readthedocs.io/en/master/" target="_blank">Marionette</a>, and <a href="https://github.com/segmentio/nightmare" target="_blank">Nightmare.js</a>–strive to provide rich APIs for configuring and interacting with Web browsers. These generally work quite well, but you’re inevitably going to end up running into API limitations if you do a lot of testing or Web scraping. You might find yourself wanting to <a href="https://intoli.com/blog/making-chrome-headless-undetectable/" target="_blank">conceal the fact that you’re using a headless browser</a>, <a href="https://intoli.com/blog/saving-images/" target="_blank">extract image resources from a Web page</a>, set the seed for <code>Math.random()</code>, or mock the browser’s geolocation before running your test suite. Your specific automation framework might provide a built-in way to accomplish some of these, but they all have their limitations.<br>
<img src="https://img.hacpai.com/bing/20180504.jpg?imageView2/1/w/960/h/520/interlace/1/q/100" alt=""></p>
<p>One option for adding custom behavior is to implement the new functionality natively to your browser automation framework and to submit a pull request. This is a great thing to do if you think that others will find it useful, but you often need a solution <em>immediately</em> and there’s no guarantee that your pull requests won’t <a href="https://github.com/SeleniumHQ/selenium/pull/5069" target="_blank">languish for months</a>. In these situations, or ones where your use case is quite niche, you’ll probably find yourself turning to JavaScript. Regardless of whether you’re using Python, Ruby, Java, or some other language, virtually all browser automation frameworks and browsers support some form of JavaScript injection. This often provides the quickest and easiest way to add custom behavior or configuration while Web scraping or writing tests.</p>
<p>There’s just one problem: not all JavaScript injection methods behave in the some way. Some execute your JavaScript code before the page is parsed by the browser while others wait until after the <a href="https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded" target="_blank">DOMContentLoaded</a> or <a href="https://developer.mozilla.org/en-US/docs/Web/Events/load" target="_blank">load</a> events have fired. The latter behavior can be very problematic in situations where it’s important that your code executes <em>before</em> any JavaScript included on a page. For instance, your geolocation mock isn’t going to do a lot of good if it’s injected after your webapp has already checked the location!</p>
<p>This means that it’s important to know not just <em>how</em> to inject JavaScript into pages, but also <em>when</em> that JavaScript will execute. In this article, we’ll develop a simple test to measure when injected JavaScript code executes and then we’ll comprehensively benchmark the various injection methods and how they behave. If you’re interested in running custom JavaScript code with Puppeteer, Selenium, Marionette, or other frameworks, then this guide should tell you everything you need to know.</p>
<h1 id="toc_h1_0">The Test Page</h1>
<p>To help measure the injection behavior, I put together a simple <a href="https://intoli.com/blog/javascript-injection/test-page.html" target="_blank">test page</a> that I could use to benchmark the different methods. The test page–which deliberately loads very slowly–will render something that looks like this</p>
<p><img src="https://intoli.com/blog/javascript-injection/img/test-page.png" alt=""></p>
<p>based on the following HTML code.</p>
<pre><code class="language-fallback highlight-chroma">&lt;html&gt;
  &lt;head&gt;
    &lt;script type="text/javascript"&gt;
      ((time) =&gt; {
        document.addEventListener('DOMContentLoaded', () =&gt; {
          document.getElementById('inlined-time').innerHTML = time;
        });
      })(Date.now());
    &lt;/script&gt;
    https://httpbin.org/delay/5"&gt;&gt;&gt;
    https://httpbin.org/delay/5"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Inlined Script Time: &lt;span id="inlined-time"&gt;&lt;/span&gt;&lt;/h1&gt;
    &lt;h1&gt;Injected Script Time: &lt;span id="injected-time"&gt;&lt;/span&gt;&lt;/h1&gt;
    https://httpbin.org/delay/5"&gt;&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>There are a few things to pay attention to here. First, you’ll notice that there’s a <code>script</code> tag immediately inside of the document <code>head</code>which immediately populates the <code>time</code> variable with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now" target="_blank">the time in milliseconds since the Unix epoch</a>. This time corresponds to the earliest possible moment that a page’s own scripts could possibly execute. The inlined script then waits until the DOM has completely loaded, finds the <code>span</code> with an <code>id</code> of <code>inlined-time</code>, and populates it with the time when the script initially executed so that we can read it easily on the test page. We will later do something similar with the <code>injected-time</code> <code>span</code> when we inject JavaScript in order to compare the execution times.</p>
<p>The other important thing going on here is that there is an external script, a stylesheet, and an image in the document. These all point to <code>https://httpbin.org/delay/5</code>, an endpoint that will wait for five seconds before responding (thanks to the awesome <a href="https://httpbin.org/" target="_blank">httpbin.org</a> site!). The response won’t correspond to a valid script, stylesheet, or image–that’s why there’s a broken <code>img</code> in the screenshot above–but browsers will wait for these resources in a realistic way. We can see exactly how they’re loaded by recording the network activity in the Chrome Developer Tools.</p>
<p><img src="https://intoli.com/blog/javascript-injection/img/network-panel.png" alt=""></p>
<p>Each resource loads sequentially and the whole page takes about 15 seconds to load. The long delay time will make it very obvious if a browser automation framework is waiting for these resources before executing injected JavaScript.</p>
<h1 id="toc_h1_1">The JavaScript Injection Methods</h1>
<p>Now all that’s left to do is to try out the different approaches. These fall into two categories:</p>
<ol>
<li><a href="https://intoli.com/blog/javascript-injection/#browser-automation-framework-methods" target="_blank">Browser Automation Framework Methods</a> - These are methods that are specific to various browser automation frameworks (_e.g._Selenium, Puppeteer, Marionette).</li>
<li><a href="https://intoli.com/blog/javascript-injection/#general-methods" target="_blank">General Methods</a> - These methods can be used with any browser automation framework. They tend to be a little more work and they also come with a few caveats in terms of browser support. They’re also way more interesting than just calling a function from a library!</li>
</ol>
<p>You can skip around between these if you would like, but the <a href="https://intoli.com/blog/javascript-injection/#chrome-and-firefox-with-selenium" target="_blank">Chrome and Firefox with Selenium</a> section lays out some common concepts that will be helpful for understanding the other sections.</p>
<h2 id="toc_h2_2">Browser Automation Framework Methods</h2>
<h3 id="toc_h3_3">Chrome and Firefox with Selenium</h3>
<p>The standard way to inject JavaScript with Selenium is to use the <a href="http://selenium-python.readthedocs.io/api.html#selenium.webdriver.remote.webdriver.WebDriver.execute_async_script" target="_blank">execute_async_script()</a> method. I put together a simple Python script called <a href="https://intoli.com/blog/javascript-injection/selenium-execute-async-script.py" target="_blank">selenium-execute-async-script.py</a> that’s designed to facilitate the benchmarking of this method. It’s contents are as follows.</p>
<pre><code class="language-fallback highlight-chroma">import os
from selenium import webdriver

# The JavaScript that we want to inject.
# This updates the second `span` with the execution time of the script.
# `arguments[0]` is how Selenium passes in the callback for `execute_async_script()`.
injected_javascript = (
    'const time = Date.now();'
    'const callback = arguments[0];'
    'const handleDocumentLoaded = () =&gt; {'
    '  document.getElementById("injected-time").innerHTML = time;'
    '  callback();'
    '};'
    'if (document.readyState === "loading") {'
    '  document.addEventListener("DOMContentLoaded", handleDocumentLoaded);'
    '} else {'
    '  handleDocumentLoaded();'
    '}'
)

# Loop through the four different configurations.
for browser in ['chrome', 'firefox']:
    for mode in ['headless', 'graphical']:
        # Set up the driver with the appropriate settings.
        if browser == 'chrome':
            options = webdriver.ChromeOptions()
            if mode == 'headless':
                options.add_argument('headless')
            driver = webdriver.Chrome(chrome_options=options)
        elif browser == 'firefox':
            if mode == 'headless':
                os.environ['MOZ_HEADLESS'] = '1'
            elif mode == 'graphical':
                os.environ.pop('MOZ_HEADLESS', None)
            driver = webdriver.Firefox()

        # Navigate to the test page and inject the JavaScript.
        driver.get('https://intoli.com/blog/javascript-injection/test-page.html')
        driver.execute_async_script(injected_javascript)

        # Save the results as an image.
        os.makedirs('img', exist_ok=True)
        filename = os.path.join('img',
            f'selenium-execute-async-script-{browser}-{mode}-results.png')
        driver.get_screenshot_as_file(filename)
        print(f'Saved "{filename}".')

        # Cleanup the driver before the next test.
        driver.quit()
</code></pre>
<p>Towards the top of the script, you can see that I defined an <code>injected_javacript</code> variable that contains JavaScript code as a string. The contents of this script are very similiar to those in the <code>script</code> tag in our test page; both are designed to record the initial script execution time and then populate the appropriate <code>span</code> with that time. The inlined script, however, was certain to execute before the <code>DOMContentLoaded</code> event while we aren’t sure ahead of time when our injected JavaScript will execute. It could be either before or after the <code>DOMContentLoaded</code> event that lets us know that our <code>span</code> is ready to be populated. To handle both scenarios, we explicitly check <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState" target="_blank">document.readyState</a> and then either update the <code>span</code> immediately or wait until <code>DOMContentLoaded</code>, as appropriate.</p>
<p>One other component of the JavaScript to notice is that we’re assigning <code>arguments[0]</code> to a variable called <code>callback</code> and then calling it after we update the <code>span</code>. What happens when we use <code>execute_async_script()</code> is that our code snippet is wrapped in a function and then this function is called with a <code>callback</code> as the argument. Even though we don’t see the function signature in our code, we can access the callback using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank">arguments</a> object. Calling this function lets Selenium know that our asynchronous code has finished running.</p>
<p>The rest of the Python code is then relatively simple; it loops through the four combinations of Chrome/Firefox and graphical/headless, visits the test page, and then saves a screenshot as an image. Note that we probably wouldn’t expect the graphical and headless results to differ much for a given browser. However, it is conceivable that some methods won’t support both modes. I’ll try to include results for both, just to make it obvious what modes are supported. I also won’t cover the headless configuration code in much detail here, but you can check out our guides to <a href="https://intoli.com/blog/running-selenium-with-headless-chrome/" target="_blank">running Selenium with headless Chrome</a> and <a href="https://intoli.com/blog/running-selenium-with-headless-firefox/" target="_blank">with headless Firefox</a> to learn more. Those guides also cover installing Selenium, Chrome, Firefox, and the appropriate drivers.</p>
<p>Finally, we can run our script with <code>python selenium-execute-async-script.py</code>. This should output something along the lines of the following.</p>
<pre><code class="language-fallback highlight-chroma">Saved "img/selenium-execute-async-script-chrome-headless-results.png".
Saved "img/selenium-execute-async-script-chrome-graphical-results.png".
Saved "img/selenium-execute-async-script-firefox-headless-results.png".
Saved "img/selenium-execute-async-script-firefox-graphical-results.png".
</code></pre>
<p>Each of these files contains a screenshot of the test page that was taken after the injected JavaScript finished executing. They look pretty similar to the screenshot that we looked at before, only now the second time is filled in.</p>
<p><img src="https://intoli.com/blog/javascript-injection/img/selenium-execute-async-script-chrome-headless-results-cropped.png" alt=""></p>
<p>What we really care about here is the relative time between the execution of the inlined and injected scripts. We can calculate the injection delay by subtracting the time that the injected script ran from the time that the inlined script ran. If the difference is negative then it means that the injected script executed first.</p>
<p>Taking a look at the injection delays for each of the configurations reveals that they’re all in the ballpark of 15 seconds.</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Mode</th>
<th>Injection Delay (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chrome</td>
<td>Graphical</td>
<td>15352</td>
</tr>
<tr>
<td>Chrome</td>
<td>Headless</td>
<td>15392</td>
</tr>
<tr>
<td>Firefox</td>
<td>Graphical</td>
<td>15596</td>
</tr>
<tr>
<td>Firefox</td>
<td>Headless</td>
<td>15540</td>
</tr>
</tbody>
</table>
<p>You’ll remember that we had added three external resources to our test page that would each take about 5 seconds to load: a script, a stylesheet, and an image. The fact that we’re seeing a 15 second delay before our injected JavaScript executes means that Selenium’s <code>execute_async_script()</code> is waiting for all of these resources to load before executing the JavaScript. More precisely, the <code>driver.get()</code>call synchronously blocks until all of these resources are loaded and we can’t call <code>execute_async_script()</code> before then. This is a major inconvenience of working with Selenium and one of the reasons why other projects have been growing in popularity recently. We’ll take a look at a couple of workarounds for Selenium later on in the <a href="https://intoli.com/blog/javascript-injection/#general-methods" target="_blank">General Methods</a> section, but first let’s take a look at some of these other frameworks.</p>
<h3 id="toc_h3_4">Firefox with Marionette</h3>
<p>If you’re only interested in automating Firefox, then <a href="https://firefox-source-docs.mozilla.org/testing/marionette/marionette/index.html" target="_blank">Marionette</a> is a relatively solid choice. The Marionette protocol is built into Firefox for remote interaction, and it’s actually how <a href="https://github.com/mozilla/geckodriver" target="_blank">geckodriver</a> communicates with Firefox when you use Selenium. Loosely speaking, this means that what is possible to do with Marionette is a superset of what is possible to do with <code>geckodriver</code> and Selenium.</p>
<p>There are both <a href="https://github.com/mozilla-b2g/gaia/tree/master/tests/jsmarionette" target="_blank">JavaScript</a> and <a href="http://marionette-client.readthedocs.io/en/master/index.html" target="_blank">Python</a> Marionette clients, but the Python one is far better documented so we’ll use that one here. Doing so will also allow us to reuse some of the code from our Selenium benchmark. One major downside of the Python client is that it’s only available as a Python 2 library… but it’s easy enough to set up a Python 2 virtual environment and install it.</p>
<pre><code class="language- highlight-chroma"><span class="highlight-err">#</span> <span class="highlight-nx">Set</span> <span class="highlight-nx">up</span> <span class="highlight-nx">a</span> <span class="highlight-nx">Python</span> <span class="highlight-mi">2</span> <span class="highlight-nx">virtualenv</span><span class="highlight-p">.</span>
<span class="highlight-nx">virtualenv</span> <span class="highlight-o">-</span><span class="highlight-nx">p</span> <span class="highlight-o">/</span><span class="highlight-nx">usr</span><span class="highlight-o">/</span><span class="highlight-nx">bin</span><span class="highlight-o">/</span><span class="highlight-nx">python2</span> <span class="highlight-nx">env</span><span class="highlight-o">/</span>
<span class="highlight-p">.</span> <span class="highlight-nx">env</span><span class="highlight-o">/</span><span class="highlight-nx">bin</span><span class="highlight-o">/</span><span class="highlight-nx">activate</span>
<span class="highlight-err">#</span> <span class="highlight-nx">Note</span> <span class="highlight-nx">that</span> <span class="highlight-nx">the</span> <span class="highlight-kn">package</span> <span class="highlight-nx">isn</span><span class="highlight-err">'</span><span class="highlight-nx">t</span> <span class="highlight-nx">called</span> <span class="highlight-s">`marionette`</span><span class="highlight-p">.</span>
<span class="highlight-nx">pip</span> <span class="highlight-nx">install</span> <span class="highlight-nx">marionette_driver</span>
</code></pre>
<p>The method for injecting JavaScript in Marionette is called <a href="http://marionette-client.readthedocs.io/en/master/reference.html#marionette_driver.marionette.Marionette.execute_async_script" target="_blank">execute_async_script()</a> and it works in much the same way as the Selenium function of the same name. This means that our new <a href="https://intoli.com/blog/javascript-injection/marionette-execute-async-script.py" target="_blank">marionette-execute-async-script.py</a> script will be quite similar to the one that we used in the previous section.</p>
<pre><code class="language-fallback highlight-chroma">import os
import time

from marionette_driver.marionette import Marionette

# The JavaScript that we want to inject.
# `arguments[0]` is how Selenium passes in the callback for `execute_async_script()`.
injected_javascript = (
    'const time = Date.now();'
    'const callback = arguments[0];'
    'const handleDocumentLoaded = () =&gt; {'
    '  document.getElementById("injected-time").innerHTML = time;'
    '  callback();'
    '};'
    'if (document.readyState === "loading") {'
    '  document.addEventListener("DOMContentLoaded", handleDocumentLoaded);'
    '} else {'
    '  handleDocumentLoaded();'
    '}'
)

# The location of the Firefox binary, will depend on system.
# Be careful to use the actual binary and not a wrapper script.
binary = '/usr/lib/firefox/firefox'

# Loop through the four different configurations.
for mode in ['headless', 'graphical']:
    # Set up the client with the appropriate settings.
    if mode == 'headless':
        os.environ['MOZ_HEADLESS'] = '1'
    else:
        os.environ.pop('MOZ_HEADLESS', None)
    client = Marionette('localhost', bin=binary, port=2828)
    client.start_session()

    # Navigate to the test page and inject the JavaScript.
    client.navigate('https://intoli.com/blog/javascript-injection/test-page.html')
    client.execute_async_script(injected_javascript)

    # Save the results as an image.
    filename = os.path.join('img',
        'marionette-execute-async-scripy-firefox-%s-results.png' % mode)
    with open(filename, 'wb') as f:
        f.write(client.screenshot(format='binary'))
    print 'Saved "%s".' % filename

    # Cleanup the client before the next test.
    client.cleanup()
</code></pre>
<p>In fact, both the <code>injected_javascript</code> and the headless configuration are completely identical between the two scripts. We now have to specify the Firefox binary location and the port to Marionette, which we didn’t with Selenium, but that’s really the only significant difference in the code. Unfortunately, the results are also quite similar.</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Mode</th>
<th>Injection Delay (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Firefox</td>
<td>Graphical</td>
<td>15453</td>
</tr>
<tr>
<td>Firefox</td>
<td>Headless</td>
<td>15530</td>
</tr>
</tbody>
</table>
<p>We see the telltale 15 second delay which reveals that our injected script isn’t being executed until all three of our slow external resources have loaded. You can inject JavaScript with Marionette, but it’s not a workaround for executing your code earlier than you can with Selenium.</p>
<h3 id="toc_h3_5">Chrome with Puppeteer</h3>
<p>The <a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank">Chrome DevTools protocol</a> defines a remote interaction mechanism for Google Chrome and Chromium which is analogous to Marionette for Firefox. It provides fine-tuned control of Chrome which extends far beyond what is possible with Selenium. That said, many people prefer to use <a href="https://github.com/GoogleChrome/puppeteer" target="_blank">Puppeteer</a> instead of a DevTools protocol client. Puppeteer, an official Google Chrome project, is built on top of a DevTools protocol client, but additionally provides a more pleasant JavaScript API than the underlying protocol.</p>
<p>Assuming that you already have <a href="http://npmjs.com/" target="_blank">NPM</a> installed on your machine, you can install Puppeteer in the usual way.</p>
<pre><code class="language-fallback highlight-chroma">npm install -g puppeteer
</code></pre>
<p>The method that we’ll use to inject our JavaScript with Puppeteer is <a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevaluateonnewdocumentpagefunction-args" target="_blank">Page.evaluateOnNewDocument()</a>. The documentation is actually pretty clear about when code that’s injected with this method executes:</p>
<blockquote>
<p>The function is invoked after the document was created but before any of its scripts were run.</p>
</blockquote>
<p>Let’s go ahead and test this anyway, both to verify the behavior and to demonstrate the usage of <code>Page.evaluateOnNewDocument()</code>. You can download the script from <a href="https://intoli.com/blog/javascript-injection/puppeteer-evaluate-on-new-document.js" target="_blank">puppeteer-evaluate-on-new-document.js</a> or check out the contents here.</p>
<pre><code class="language-fallback highlight-chroma">const puppeteer = require('puppeteer');

const runTest = async (mode) =&gt; {
  const browser = await puppeteer.launch({
    args: ['--no-sandbox'],
    headless: mode === 'headless',
  });
  const page = await browser.newPage();
  await page.evaluateOnNewDocument(() =&gt; {
    const time = Date.now();
    const handleDocumentLoaded = () =&gt; {
      document.getElementById("injected-time").innerHTML = time;
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", handleDocumentLoaded);
    } else {
      handleDocumentLoaded();
    }
  });
  await page.goto('https://intoli.com/blog/javascript-injection/test-page.html');
  const filename = `img/puppeteer-evaluate-on-new-document-chrome-${mode}.png`;
  await page.screenshot({ path: filename });
  console.log(`Saved "${filename}".`);

  await browser.close();
};

(async () =&gt; {
  await runTest('headless');
  await runTest('graphical');
})();
</code></pre>
<p>The syntax obviously looks quite different from our previous Python scripts, but the logic has a few significant differences as well. Notably, we’re calling <code>Page.evaluateOnNewDocument()</code> <em>before</em> we navigate to our test page. In our previous examples, we were bottlenecked by waiting for the page navigation methods to return before we could inject our JavaScript. It doesn’t really matter how long the <code>page.goto()</code> promise takes to resolve in this case because Puppeteer already knows what JavaScript to inject.</p>
<p>Another thing to notice is that we’re injecting raw JavaScript instead of a string. The easy interoperation between the browser and control code is one of the nice things about using a browser automation framework written in JavaScript. It’s not a huge deal either way, but it does eliminate some context switching and makes serialization/marshalling easier to deal with.</p>
<p>Anyway, running our script with <code>node puppeteer-evaluate-on-new-document.js</code> produces the following results.</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Mode</th>
<th>Injection Delay (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chrome</td>
<td>Graphical</td>
<td>-6</td>
</tr>
<tr>
<td>Chrome</td>
<td>Headless</td>
<td>-8</td>
</tr>
</tbody>
</table>
<p>Remember that the negative injection delay means that our code is being evaluated before our inlined script tag in the header. This is the ideal situation because it means that we can be certain that any modifications to the JavaScript environment occur before any page code is executed. You can always attach event listeners at this stage to wait for page load events–like we did in the injected script–if you have code that needs to wait for the DOM to be ready or any other conditions.</p>
<h2 id="toc_h2_6">General Methods</h2>
<h3 id="toc_h3_7">Chrome and Firefox with a Custom WebExtension</h3>
<p>Writing a custom <a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions" target="_blank">WebExtension</a> is one of my favorite ways to add functionality to a browser during automation. There’s a little bit of a learning curve if you haven’t written one before, but the extension API is extremely powerful. It’s also quite nice that extensions are pretty much <a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Browser_support_for_JavaScript_APIs" target="_blank">cross-browser compatible</a> out of the box these days. The one major downside is that <a href="https://groups.google.com/a/chromium.org/forum/#!topic/headless-dev/nEoeUkoNI0o" target="_blank">headless Chrome still doesn’t support WebExtensions</a>. If that’s not a requirement for you, then a custom extension offers a level of customizability that even the best browser automation frameworks can’t compete with.</p>
<p>Let’s start on this one by making an <code>extension</code> directory that we’ll put two files inside of. The first should be called <a href="https://intoli.com/blog/javascript-injection/extension/manifest.json" target="_blank">manifest.json</a> and have the following contents.</p>
<pre><code class="language-fallback highlight-chroma">{
  "manifest_version": 2,
  "name": "JavaScript Injection Test Extension",
  "version": "1.0.0",
  "applications": {
    "gecko": {
      "id": "javascript-injection@intoli.com"
    }
  },
  "content_scripts": [
    {
      "matches": ["*://*/*"],
      "js": ["injected-javascript.js"],
      "run_at": "document_start"
    }
  ]
}
</code></pre>
<p>This is mostly the <a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Anatomy_of_a_WebExtension#manifest.json" target="_blank">minimal boilerplate</a> required to define an extension with the exception of the <code>content_scripts</code> section. This tells the browser to inject a file called <code>injected-javascript.js</code> on every page load that matches <code>*://*/*</code> (<em>i.e.</em> every page load). The <code>run_at</code>parameter being set to <code>document_start</code> specifies that the script should be injected as soon as possible.</p>
<p>Now we just need to create the <a href="https://intoli.com/blog/javascript-injection/extension/injected-javascript.js" target="_blank">injected-javascript.js</a> file. It’s contents will be pretty much the same as all the other JavaScript that we’ve been injecting.</p>
<pre><code class="language-fallback highlight-chroma">((time) =&gt; {
  const handleDocumentLoaded = () =&gt; {
    document.getElementById("injected-time").innerHTML = time;
  };
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", handleDocumentLoaded);
  } else {
    handleDocumentLoaded();
  }
})(Date.now());
</code></pre>
<p>These two files give us a fully functional extension, but we’ll still need to automate the browser in order to install it, navigate to pages, take screenshots, <em>etc</em>. We can reuse much of the logic from our earlier Selenium script for this and adapt it to install the extension instead of calling <code>execute_async_script()</code>. This is <a href="https://stackoverflow.com/questions/20782557/load-unpacked-chrome-extension-programatically" target="_blank">really easy with Chrome</a>; all we need to do is add a <code>--load-extension=extension</code>flag. Firefox is a little more tricky because it doesn’t have a similar flag and Selenium has only partial support for the now-standard WebExtensions format. There’s a big fat hack at the top of this <a href="https://intoli.com/blog/javascript-injection/selenium-custom-web-extension.py" target="_blank">selenium-custom-web-extension.py</a> script because of that. I recommend checking out <a href="https://intoli.com/blog/firefox-extensions-with-selenium/" target="_blank">Using Firefox WebExtensions with Selenium</a> if you would like to learn more about what that part is doing.</p>
<pre><code class="language-fallback highlight-chroma">from selenium import webdriver
from selenium.webdriver.firefox.firefox_profile import AddonFormatError

# This must be the developer edition to use an unsigned extension.
firefox_binary = '/usr/bin/firefox-developer-edition'
extension_directory = 'extension'

# Patch in support for WebExtensions in Firefox.
# See: https://intoli.com/blog/firefox-extensions-with-selenium/
class FirefoxProfileWithWebExtensionSupport(webdriver.FirefoxProfile):
    def _addon_details(self, addon_path):
        try:
            return super()._addon_details(addon_path)
        except AddonFormatError:
            try:
                with open(os.path.join(addon_path, 'manifest.json'), 'r') as f:
                    manifest = json.load(f)
                    return {
                        'id': manifest['applications']['gecko']['id'],
                        'version': manifest['version'],
                        'name': manifest['name'],
                        'unpack': False,
                    }
            except (IOError, KeyError) as e:
                raise AddonFormatError(str(e), sys.exc_info()[2])
webdriver.FirefoxProfile = FirefoxProfileWithWebExtensionSupport

# Loop through the four different configurations.
for browser in ['chrome', 'firefox']:
    for mode in ['headless', 'graphical']:
        # Set up the driver with the appropriate settings.
        if browser == 'chrome':
            options = webdriver.ChromeOptions()
            if mode == 'headless':
                options.add_argument('headless')
            options.add_argument(f'load-extension={extension_directory}')
            driver = webdriver.Chrome(chrome_options=options)
        elif browser == 'firefox':
            if mode == 'headless':
                os.environ['MOZ_HEADLESS'] = '1'
            elif mode == 'graphical':
                os.environ.pop('MOZ_HEADLESS', None)
            profile = webdriver.FirefoxProfile()
            profile.add_extension(extension_directory)
            driver = webdriver.Firefox(profile, firefox_binary=firefox_binary)

        # Navigate to the test page and let the extension do its thing.
        driver.get('https://intoli.com/blog/javascript-injection/test-page.html')

        # Save the results as an image.
        os.makedirs('img', exist_ok=True)
        filename = os.path.join('img',
            f'selenium-custom-web-extension-{browser}-{mode}-results.png')
        driver.get_screenshot_as_file(filename)
        print(f'Saved "{filename}".')

        # Cleanup the driver before the next test.
        driver.quit()
</code></pre>
<p>Outside of the extension loading, the rest of the script should look almost identical to our previous Selenium script. Running it produces the following results.</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Mode</th>
<th>Injection Delay (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chrome</td>
<td>Graphical</td>
<td>-1</td>
</tr>
<tr>
<td>Chrome</td>
<td>Headless</td>
<td>N/A</td>
</tr>
<tr>
<td>Firefox</td>
<td>Graphical</td>
<td>-2</td>
</tr>
<tr>
<td>Firefox</td>
<td>Headless</td>
<td>-2</td>
</tr>
</tbody>
</table>
<p>There’s no result for headless Chrome because it doesn’t support extensions, but all of the other configurations successfully inject and execute the JavaScript before the inlined code executes.</p>
<h3 id="toc_h3_8">Chrome and Firefox with mitmproxy</h3>
<p>Another fun way to inject JavaScript is to use <a href="https://mitmproxy.org/" target="_blank">mitmproxy</a>. If you’re not familiar with it, <code>mitmproxy</code> is an SSL-capable intercepting proxy. It allows you to intercept, modify, and otherwise have your way with any traffic that’s directing through the proxy. The basic approach that we’ll take is to intercept HTML requests and inject a new <code>script</code> tag into the <code>head</code> before any other contents.</p>
<p><code>mitmproxy</code> has a <a href="http://docs.mitmproxy.org/en/v0.17/scripting/inlinescripts.html" target="_blank">scripting API</a> that you can use to implement custom behavior like this using Python. Creating a file called <a href="https://intoli.com/blog/javascript-injection/mitm-injector.py" target="_blank">mitm-injector.py</a> with the following contents will accomplish our goal of injecting a custom script.</p>
<pre><code class="language-fallback highlight-chroma">from bs4 import BeautifulSoup
from mitmproxy import ctx

# Load in the javascript to inject.
with open('extension/injected-javascript.js', 'r') as f:
    injected_javascript = f.read()

def response(flow):
    # Only process 200 responses of HTML content.
    if flow.response.headers['Content-Type'] != 'text/html':
        return
    if not flow.response.status_code == 200:
        return

    # Inject a script tag containing the JavaScript.
    html = BeautifulSoup(flow.response.text, 'lxml')
    container = html.head or html.body
    if container:
        script = html.new_tag('script', type='text/javascript')
        script.string = injected_javascript
        container.insert(0, script)
        flow.response.text = str(html)

        ctx.log.info('Successfully injected the `injected-javascript.js` script.')
</code></pre>
<p>You’ll first notice that we’re loading in the exact content script from our WebExtension: <a href="https://intoli.com/blog/javascript-injection/extension/injected-javascript.js" target="_blank">extension/injected-javascript.js</a>. Our <code>response(flow)</code> method then gets called for each request, but only does anything for successful HTML requests. In that case, the document is parsed using <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank">Beautiful Soup</a>, a script tag created and injected, and the response text overwritten with the new HTML code. You could alternatively use a regular expression here to modify the opening <code>head</code> tag, but that can be less reliable than using a parser if odd formatting is encountered.</p>
<p>The non-interactive version of <code>mitmproxy</code> can be launched and configured to use our custom script by running the following.</p>
<pre><code class="language-fallback highlight-chroma">mitmdump -p 8080 -s mitm-injector.py
</code></pre>
<p>This will start the proxy listening for connections on port 8080. We’ll still need a way to launch and control the browsers, so we’ll again use a modified version of our original Selenium script. This one is called <a href="https://intoli.com/blog/javascript-injection/selenium-mitmproxy.py" target="_blank">selenium-mitmproxy.py</a> and the only real modification is to configure the browsers to use the local proxy that we just set up. This can be done in Firefox by specifying <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Preferences/Mozilla_networking_preferences" target="_blank">Firefox network preferences</a> in the profile. In Chrome, we can just use the <code>--proxy</code> command-line argument.</p>
<pre><code class="language-fallback highlight-chroma">import os

from selenium import webdriver

# The proxy settings.
proxy_host = 'localhost'
proxy_port = 8080

# Loop through the four different configurations.
for browser in ['chrome']:
    for mode in ['headless']:
        # Set up the driver with the appropriate settings.
        if browser == 'chrome':
            # Enable headless mode.
            options = webdriver.ChromeOptions()
            if mode == 'headless':
                options.add_argument('--headless')

            # Specify the proxy.
            options.add_argument('--proxy-server=%s:%s' % (proxy_host, proxy_port))

            # Launch Chrome.
            driver = webdriver.Chrome(chrome_options=options)

        elif browser == 'firefox':
            # Enable headless mode.
            if mode == 'headless':
                os.environ['MOZ_HEADLESS'] = '1'
            elif mode == 'graphical':
                os.environ.pop('MOZ_HEADLESS', None)

            firefox_profile = webdriver.FirefoxProfile()
            # Specify to use manual proxy configuration.
            firefox_profile.set_preference('network.proxy.type', 1)
            # Set the host/port.
            firefox_profile.set_preference('network.proxy.http', proxy_host)
            firefox_profile.set_preference('network.proxy.https_port', proxy_port)
            firefox_profile.set_preference('network.proxy.ssl', proxy_host)
            firefox_profile.set_preference('network.proxy.ssl_port', proxy_port)

            # Launch Firefox.
            driver = webdriver.Firefox(firefox_profile=firefox_profile)

        # Navigate to the test page and inject the JavaScript.
        driver.get('https://intoli.com/blog/javascript-injection/test-page.html')

        # Save the results as an image.
        os.makedirs('img', exist_ok=True)
        filename = os.path.join('img',
            f'selenium-mitmproxy-{browser}-{mode}-results.png')
        driver.get_screenshot_as_file(filename)
        print(f'Saved "{filename}".')

        # Cleanup the driver before the next test.
        driver.quit()
</code></pre>
<p>The <code>mitmdump</code> process will spit out a lot of logging information while this script runs, including one notable error.</p>
<pre><code class="language-fallback highlight-chroma">Proxy server listening at http://0.0.0.0:8080
127.0.0.1:38024: clientconnect
127.0.0.1:38024: CONNECT intoli.com:443
 &lt;&lt; Cannot establish TLS with client (sni: intoli.com): TlsException("(104, 'ECONNRESET')",)
</code></pre>
<p>We see this because Chrome currently <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=721739" target="_blank">doesn’t support ignoring certificate errors in headless mode</a>. This is going to change extremely soon–in Chrome 65 to be exact–but we won’t be able to intercept SSL traffic in Chrome headless until then. The rest of the configurations should work successfully though and produce results roughly comparable to the following.</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Mode</th>
<th>Injection Delay (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chrome</td>
<td>Graphical</td>
<td>-1</td>
</tr>
<tr>
<td>Chrome</td>
<td>Headless</td>
<td>N/A</td>
</tr>
<tr>
<td>Firefox</td>
<td>Graphical</td>
<td>-1</td>
</tr>
<tr>
<td>Firefox</td>
<td>Headless</td>
<td>-1</td>
</tr>
</tbody>
</table>
<p>The results look great, but it’s definitely a little bit janky to modify the HTML of the pages like this. I would generally try to avoid this approach if one of the other methods works for you.</p>
<h3 id="toc_h3_9">Conclusion</h3>
<p>Whatever your JavaScript injection needs, I hope that you were able to find some useful information here! Even if you don’t use one of the frameworks that we investigated, the WebExtension and <code>mitmproxy</code> should work with a variety of different automation frameworks. If you have any interesting approaches of your own then we would love to hear about them in the comments.</p>
<p>As always, please feel free <a href="https://intoli.com/contact/" target="_blank">to get in touch with us here at Intoli</a>. Our team has broad expertise in Web scraping and data intelligence, and we would really love to hear about what you’re working on. We also have <a href="http://intoli.us11.list-manage.com/subscribe?u=e95178aac513dc319bf87a9c3&amp;id=bb722b0e5d" target="_blank">a pretty awesome monthly newsletter</a> where we send out our favorite articles every month!</p>
<p>感谢原作者，博客转自：<a href="https://intoli.com/blog/javascript-injection/" target="_blank">https://intoli.com/blog/javascript-injection/</a></p>
                </div>

                <footer class="tags">
                        <a class="tag" rel="tag" href="https://zxniuniu.github.io/tags/Mitmproxy">
                            Mitmproxy</a>
                        <a class="tag" rel="tag" href="https://zxniuniu.github.io/tags/Selenium">
                            Selenium</a>
                        <a class="tag" rel="tag" href="https://zxniuniu.github.io/tags/%E4%BB%A3%E7%90%86">
                            代理</a>
                        <a class="tag" rel="tag" href="https://zxniuniu.github.io/tags/%E7%88%AC%E8%99%AB">
                            爬虫</a>

                    <div class="rel fn-clear ft__center">
                            <a href="https://zxniuniu.github.io/articles/2018/10/12/1539357030798.html" rel="prev"
                               class="fn-left vditor-tooltipped vditor-tooltipped__n"
                               aria-label="App爬虫神器Mitmproxy和Mitmdump的使用">
                                旧一篇
                            </a>
<div class="article__share"
     data-title="Javascript Injection With Selenium, Puppeteer, And Marionette In Chrome And Firefox"
     data-blogtitle="随心笔客"
     data-url="https://zxniuniu.github.io/articles/2018/10/12/1539357955729.html"
     data-avatar="https://img.hacpai.com/avatar/1538398487257_1540086121348.jpeg?imageView2/1/w/128/h/128/interlace/0/q/100">
    <span class="item" data-type="qqz">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M22.824 13.989l-8.348 6.287s3.351 0.522 8.404 0.461l-0.23-1.040 7.2-6.549c0.132-0.12 0.183-0.312 0.129-0.487s-0.203-0.299-0.377-0.314l-9.492-0.856-3.708-9.213c-0.068-0.169-0.226-0.279-0.401-0.279s-0.333 0.11-0.401 0.279l-3.708 9.213-9.492 0.856c-0.174 0.015-0.323 0.139-0.377 0.314s-0.004 0.366 0.129 0.487l7.2 6.549-2.158 9.742c-0.040 0.178 0.026 0.365 0.168 0.474 0.142 0.107 0.331 0.115 0.481 0.021l8.158-5.165 8.158 5.165c0.070 0.045 0.147 0.066 0.225 0.066 0.090 0 0.18-0.029 0.256-0.086 0.142-0.109 0.208-0.295 0.168-0.474l-1.707-7.704c0.732-0.386 1.538-1.040 1.538-1.040s-3.195 1.638-14.664 0.838l8.312-6.325s-0.327-0.534-10.744-0.914c-0.697-0.026 8.493-1.83 15.281-0.305z"></path>
        </svg>
    </span>
    <span class="item" data-type="wechat">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M9.062 9.203c0-0.859-0.562-1.422-1.422-1.422-0.844 0-1.703 0.562-1.703 1.422 0 0.844 0.859 1.406 1.703 1.406 0.859 0 1.422-0.562 1.422-1.406zM20.672 17.125c0-0.562-0.562-1.125-1.422-1.125-0.562 0-1.125 0.562-1.125 1.125 0 0.578 0.562 1.141 1.125 1.141 0.859 0 1.422-0.562 1.422-1.141zM16.984 9.203c0-0.859-0.562-1.422-1.406-1.422-0.859 0-1.703 0.562-1.703 1.422 0 0.844 0.844 1.406 1.703 1.406 0.844 0 1.406-0.562 1.406-1.406zM26.906 17.125c0-0.562-0.578-1.125-1.422-1.125-0.562 0-1.125 0.562-1.125 1.125 0 0.578 0.562 1.141 1.125 1.141 0.844 0 1.422-0.562 1.422-1.141zM22.75 10.922c-0.359-0.047-0.719-0.063-1.094-0.063-5.375 0-9.625 4.016-9.625 8.953 0 0.828 0.125 1.625 0.359 2.375-0.359 0.031-0.703 0.047-1.063 0.047-1.422 0-2.547-0.281-3.969-0.562l-3.953 1.984 1.125-3.406c-2.828-1.984-4.531-4.547-4.531-7.656 0-5.391 5.094-9.625 11.328-9.625 5.563 0 10.453 3.391 11.422 7.953zM32 19.687c0 2.547-1.688 4.813-3.969 6.516l0.859 2.828-3.109-1.703c-1.141 0.281-2.281 0.578-3.406 0.578-5.391 0-9.625-3.688-9.625-8.219s4.234-8.219 9.625-8.219c5.094 0 9.625 3.688 9.625 8.219z"></path>
        </svg>
    </span>
    <span class="item" data-type="weibo">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M13.444 27.064c-5.3 0.525-9.875-1.875-10.219-5.35-0.344-3.481 3.675-6.719 8.969-7.244 5.3-0.525 9.875 1.875 10.212 5.35 0.35 3.481-3.669 6.725-8.963 7.244zM24.038 15.521c-0.45-0.137-0.762-0.225-0.525-0.819 0.512-1.287 0.563-2.394 0.006-3.188-1.038-1.481-3.881-1.406-7.137-0.037 0 0-1.025 0.444-0.762-0.363 0.5-1.613 0.425-2.956-0.356-3.737-1.769-1.769-6.469 0.069-10.5 4.1-3.013 3.006-4.763 6.212-4.763 8.981 0 5.287 6.787 8.506 13.425 8.506 8.7 0 14.494-5.056 14.494-9.069 0-2.431-2.044-3.806-3.881-4.375z"></path>
            <path d="M29.819 5.833c-2.1-2.331-5.2-3.219-8.063-2.612v0c-0.663 0.144-1.081 0.794-0.938 1.45 0.144 0.662 0.788 1.081 1.45 0.938 2.038-0.431 4.238 0.2 5.731 1.856s1.9 3.913 1.256 5.888v0c-0.206 0.644 0.144 1.331 0.788 1.544 0.644 0.206 1.331-0.144 1.544-0.787v-0.006c0.9-2.762 0.331-5.938-1.769-8.269z"></path>
            <path d="M26.588 8.752c-1.025-1.138-2.538-1.569-3.925-1.269-0.569 0.119-0.931 0.688-0.813 1.256 0.125 0.569 0.688 0.931 1.25 0.806v0c0.681-0.144 1.419 0.069 1.919 0.619 0.5 0.556 0.637 1.313 0.419 1.975v0c-0.175 0.55 0.125 1.15 0.681 1.331 0.556 0.175 1.15-0.125 1.331-0.681 0.438-1.356 0.163-2.906-0.863-4.037z"></path>
            <path d="M13.738 20.771c-0.188 0.319-0.594 0.469-0.912 0.337-0.319-0.125-0.412-0.488-0.231-0.794 0.188-0.306 0.581-0.456 0.894-0.337 0.313 0.113 0.425 0.469 0.25 0.794zM12.044 22.933c-0.512 0.819-1.613 1.175-2.438 0.8-0.813-0.369-1.056-1.319-0.544-2.119 0.506-0.794 1.569-1.15 2.388-0.806 0.831 0.356 1.1 1.3 0.594 2.125zM13.969 17.146c-2.519-0.656-5.369 0.6-6.463 2.819-1.119 2.262-0.037 4.781 2.506 5.606 2.638 0.85 5.75-0.456 6.831-2.894 1.069-2.394-0.262-4.85-2.875-5.531z"></path>
        </svg>
    </span>
    <span class="item" data-type="twitter">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M32.003 6.075c-1.175 0.525-2.444 0.875-3.769 1.031 1.356-0.813 2.394-2.1 2.887-3.631-1.269 0.75-2.675 1.3-4.169 1.594-1.2-1.275-2.906-2.069-4.794-2.069-3.625 0-6.563 2.938-6.563 6.563 0 0.512 0.056 1.012 0.169 1.494-5.456-0.275-10.294-2.888-13.531-6.862-0.563 0.969-0.887 2.1-0.887 3.3 0 2.275 1.156 4.287 2.919 5.463-1.075-0.031-2.087-0.331-2.975-0.819 0 0.025 0 0.056 0 0.081 0 3.181 2.263 5.838 5.269 6.437-0.55 0.15-1.131 0.231-1.731 0.231-0.425 0-0.831-0.044-1.237-0.119 0.838 2.606 3.263 4.506 6.131 4.563-2.25 1.762-5.075 2.813-8.156 2.813-0.531 0-1.050-0.031-1.569-0.094 2.913 1.869 6.362 2.95 10.069 2.95 12.075 0 18.681-10.006 18.681-18.681 0-0.287-0.006-0.569-0.019-0.85 1.281-0.919 2.394-2.075 3.275-3.394z"></path>
        </svg>
    </span>
    <span class="item__qr"></span>
</div>                            <a href="https://zxniuniu.github.io/articles/2018/10/18/1539837869502.html" rel="next"
                               class="fn-right vditor-tooltipped vditor-tooltipped__n"
                               aria-label="A Web Developer’s Guide to Browser Caching">
                                新一篇
                            </a>
                    </div>
                </footer>
                    <div id="gitalk-container"></div>
                    <div id="b3logsolocomments"></div>
                    <div id="vcomment" data-name="zxniuniu" data-postId="1539357955729"></div>
                <br>
                <div id="externalRelevantArticles" class="list"></div>
                <div id="relevantArticles" class="list"></div>
                <div id="randomArticles" class="list"></div>
            </article>
        </main>
<aside>
<ul class="article__toc">
        <li class="toc__h1">
            <a href="#toc_h1_0">The Test Page</a>
        </li>
        <li class="toc__h1">
            <a href="#toc_h1_1">The JavaScript Injection Methods</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_2">Browser Automation Framework Methods</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_3">Chrome and Firefox with Selenium</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_4">Firefox with Marionette</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_5">Chrome with Puppeteer</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_6">General Methods</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_7">Chrome and Firefox with a Custom WebExtension</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_8">Chrome and Firefox with mitmproxy</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_9">Conclusion</a>
        </li>
</ul></aside>
    </div>
</div>
<footer class="footer fn-clear">
    &copy; 2020
    <a href="https://zxniuniu.github.io">随心笔客</a>
    <!--<script>
  document.addEventListener("DOMContentLoaded", function (event) {
    if (Label.articleId) {
      const gitalk = new Gitalk({
        clientID: '9e3b567fd3adfbc50216',
        clientSecret: '7aed9ad9b65cd6322b2fe3cdcaa4178d093ed3a7',
        repo: 'solo-blog',
        owner: 'zxniuniu',
        admin: ['zxniuniu'],
        id: Label.articleId,
        distractionFreeMode: false
      })

      gitalk.render('gitalk-container')
    }
  })
</script>-->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?39a78d58b860487e6244a92beef4d745";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</footer>
<div class="icon-up" onclick="Util.goTop()"></div>
<script>
  var Label = {
    speech: false,
    servePath: "https://zxniuniu.github.io",
    staticServePath: "https://cdn.jsdelivr.net/gh/88250/solo@4.3.1/src/main/resources",
    luteAvailable: true,
    hljsStyle: 'github',
    langLabel: "zh_CN",
    version: "4.3.1",
    staticSite: true,
    showCodeBlockLn: true,
    articleId: "1539357955729",
  }
</script>
<script src="https://cdn.jsdelivr.net/gh/88250/solo@4.3.1/src/main/resources/skins/9IPHP/js/common.min.js?1606610382706"></script>

<script type="text/javascript">
    Util.addScript('https://cdn.jsdelivr.net/gh/88250/solo@4.3.1/src/main/resources/js/page.min.js?1606610382706', 'soloPageScript')
    var page = new Page({
        "commentContentCannotEmptyLabel": "评论不能为空",
        "oId": "1539357955729",
        "blogHost": "https://zxniuniu.github.io",
        "randomArticles1Label": "随机阅读：",
        "externalRelevantArticles1Label": "站外相关阅读："
    });
    $(document).ready(function () {
        page.load();
    page.tips.externalRelevantArticlesDisplayCount = "10";
        page.loadRandomArticles();
        page.loadExternalRelevantArticles("Mitmproxy,Selenium,代理,爬虫", "<header class='title'><h2>站外相关阅读</h2></header>");
        page.loadRelevantArticles('1539357955729', '<h4>相关阅读</h4>');
    Skin.initToc()
    page.share()
    });
</script>
</body>
</html>

<!-- Generated by Latke (https://github.com/88250/latke) in 27ms, 2020/11/29 22:19:05 -->